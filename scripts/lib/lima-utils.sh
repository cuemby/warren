#!/usr/bin/env bash
#
# Lima Utilities Library
#
# This library provides functions for managing Lima VMs for Warren deployment.
# It handles VM creation, networking, and lifecycle management.
#

# Source this file from your main script:
#   source "$(dirname "$0")/lib/lima-utils.sh"

# ============================================================================
# LIMA VM MANAGEMENT
# ============================================================================

# Create a Lima VM with Warren configuration
# Usage: lima_create_vm <vm_name> <cpus> <memory_gb>
lima_create_vm() {
  local vm_name="$1"
  local cpus="$2"
  local memory="$3"

  log_verbose "Creating VM: ${vm_name} (${cpus} CPUs, ${memory}GB RAM)"

  # Check if VM already exists
  if limactl list | grep -q "^${vm_name} "; then
    local status=$(limactl list | grep "^${vm_name} " | awk '{print $2}')
    if [[ "$status" == "Running" ]]; then
      log_info "VM ${vm_name} already exists and is running"
      return 0
    else
      log_warning "VM ${vm_name} exists but is not running - restarting"
      execute "limactl start ${vm_name}"
      return 0
    fi
  fi

  # Generate Lima YAML config
  local lima_yaml="/tmp/${vm_name}.yaml"
  lima_generate_config "$vm_name" "$cpus" "$memory" > "$lima_yaml"

  # Create and start VM
  progress_start "Creating VM ${vm_name}"
  if execute "limactl start --tty=false ${lima_yaml}"; then
    progress_done
    rm -f "$lima_yaml"
    return 0
  else
    progress_fail
    rm -f "$lima_yaml"
    return 1
  fi
}

# Generate Lima VM configuration
# Usage: lima_generate_config <vm_name> <cpus> <memory_gb>
lima_generate_config() {
  local vm_name="$1"
  local cpus="$2"
  local memory="$3"
  local arch=$(get_arch)

  cat <<EOF
# Lima VM configuration for Warren - ${vm_name}
# Generated by Warren deployment script

vmType: "qemu"

# Architecture-specific OS images
images:
  - location: "https://cloud-images.ubuntu.com/releases/22.04/release/ubuntu-22.04-server-cloudimg-amd64.img"
    arch: "x86_64"
  - location: "https://cloud-images.ubuntu.com/releases/22.04/release/ubuntu-22.04-server-cloudimg-arm64.img"
    arch: "aarch64"

cpus: ${cpus}
memory: "${memory}GiB"
disk: "20GiB"

# Mount Warren workspace (read-only to prevent accidental modifications)
mounts:
  - location: "${WARREN_ROOT}"
    writable: false
    9p:
      securityModel: none
      cache: "mmap"
  - location: "${WARREN_ROOT}/bin"
    writable: true
    9p:
      securityModel: none
      cache: "mmap"

ssh:
  localPort: 0
  loadDotSSHPubKeys: true
  forwardAgent: false

firmware:
  legacyBIOS: false

# User-v2 networking for VM-to-VM communication
networks:
  - lima: user-v2

hostResolver:
  enabled: true
  hosts:
    host.lima.internal: host.lima.internal

portForwards:
  - guestPort: ${WARREN_API_PORT}
    hostPort: ${WARREN_API_PORT}
    proto: tcp
  - guestPort: ${WARREN_METRICS_PORT}
    hostPort: ${WARREN_METRICS_PORT}
    proto: tcp

# Use system containerd
containerd:
  system: true
  user: false

# Provision script
provision:
  - mode: system
    script: |
      #!/bin/bash
      set -eux -o pipefail

      # Update package list
      export DEBIAN_FRONTEND=noninteractive
      apt-get update -qq

      # Install required packages
      apt-get install -y -qq \\
        curl wget git make \\
        net-tools dnsutils iputils-ping \\
        jq vim htop

      # Install containerd if not present
      if ! command -v containerd &> /dev/null; then
        apt-get install -y -qq containerd
      fi

      # Configure containerd
      mkdir -p /etc/containerd
      containerd config default > /etc/containerd/config.toml
      sed -i 's/SystemdCgroup = false/SystemdCgroup = true/' /etc/containerd/config.toml

      # Enable and start containerd
      systemctl enable containerd
      systemctl restart containerd

      # Create Warren directories
      mkdir -p /var/lib/warren /etc/warren /var/log/warren
      chown -R ubuntu:ubuntu /var/lib/warren /var/log/warren

      # Configure systemd-resolved for .internal domains
      mkdir -p /etc/systemd/resolved.conf.d
      cat > /etc/systemd/resolved.conf.d/lima.conf <<'RESOLV'
      [Resolve]
      MulticastDNS=yes
      LLMNR=yes
      RESOLV
      systemctl restart systemd-resolved

      # Verify containerd
      timeout 30 sh -c 'until systemctl is-active containerd; do sleep 1; done'

      echo "✓ Warren VM ${vm_name} provisioned successfully"

  - mode: user
    script: |
      #!/bin/bash
      set -eux -o pipefail

      # Create convenient symlink to Warren workspace
      ln -sf /tmp/lima${WARREN_ROOT} ~/warren || true

      echo "✓ User environment configured for ${vm_name}"

probes:
  - description: "containerd to be running"
    script: |
      #!/bin/bash
      set -eux -o pipefail
      timeout 30 bash -c 'until systemctl is-active containerd; do sleep 1; done'
    hint: |
      containerd is not running. Check logs: sudo journalctl -u containerd

  - description: "user-v2 network to be ready"
    script: |
      #!/bin/bash
      set -eux -o pipefail
      # Ping the gateway
      timeout 10 bash -c 'until ping -c 1 192.168.104.1 &>/dev/null; do sleep 1; done'
    hint: |
      user-v2 network not ready. Required for VM-to-VM communication.

message: |
  ✓ Warren VM ${vm_name} is ready!

  Access: limactl shell ${vm_name}
  Warren workspace: ~/warren

EOF
}

# Delete a Lima VM
# Usage: lima_delete_vm <vm_name>
lima_delete_vm() {
  local vm_name="$1"

  if limactl list | grep -q "^${vm_name} "; then
    log_verbose "Deleting VM: ${vm_name}"
    execute "limactl delete -f ${vm_name}"
  fi
}

# Start a stopped Lima VM
# Usage: lima_start_vm <vm_name>
lima_start_vm() {
  local vm_name="$1"

  if ! limactl list | grep "^${vm_name} " | grep -q "Running"; then
    log_verbose "Starting VM: ${vm_name}"
    execute "limactl start ${vm_name}"
  fi
}

# Stop a running Lima VM
# Usage: lima_stop_vm <vm_name>
lima_stop_vm() {
  local vm_name="$1"

  if limactl list | grep "^${vm_name} " | grep -q "Running"; then
    log_verbose "Stopping VM: ${vm_name}"
    execute "limactl stop ${vm_name}"
  fi
}

# Execute command in Lima VM
# Usage: lima_exec <vm_name> <command>
lima_exec() {
  local vm_name="$1"
  shift
  local cmd="$*"

  log_verbose "Executing in ${vm_name}: ${cmd}"
  execute "limactl shell ${vm_name} ${cmd}"
}

# Execute command as root in Lima VM
# Usage: lima_exec_root <vm_name> <command>
lima_exec_root() {
  local vm_name="$1"
  shift
  local cmd="$*"

  log_verbose "Executing as root in ${vm_name}: ${cmd}"
  execute "limactl shell ${vm_name} sudo ${cmd}"
}

# Get VM IP address
# Usage: lima_get_ip <vm_name>
lima_get_ip() {
  local vm_name="$1"

  # Get IP from Lima
  limactl shell "${vm_name}" ip -4 addr show lima0 | grep inet | awk '{print $2}' | cut -d/ -f1 | head -1
}

# Wait for VM to be ready
# Usage: lima_wait_ready <vm_name> [timeout_seconds]
lima_wait_ready() {
  local vm_name="$1"
  local timeout="${2:-120}"
  local elapsed=0

  progress_start "Waiting for ${vm_name} to be ready"

  while [[ $elapsed -lt $timeout ]]; do
    if limactl list | grep "^${vm_name} " | grep -q "Running"; then
      # Check if we can execute commands
      if lima_exec "${vm_name}" "echo ready" &>/dev/null; then
        progress_done
        return 0
      fi
    fi

    sleep 2
    elapsed=$((elapsed + 2))
  done

  progress_fail
  log_error "VM ${vm_name} did not become ready within ${timeout} seconds"
  return 1
}

# Copy file to VM
# Usage: lima_copy_to_vm <vm_name> <local_file> <remote_path>
lima_copy_to_vm() {
  local vm_name="$1"
  local local_file="$2"
  local remote_path="$3"

  log_verbose "Copying ${local_file} to ${vm_name}:${remote_path}"

  # Use limactl copy command
  execute "limactl copy ${local_file} ${vm_name}:${remote_path}"
}

# Copy file from VM
# Usage: lima_copy_from_vm <vm_name> <remote_path> <local_file>
lima_copy_from_vm() {
  local vm_name="$1"
  local remote_path="$2"
  local local_file="$3"

  log_verbose "Copying ${vm_name}:${remote_path} to ${local_file}"

  # Use limactl copy command
  execute "limactl copy ${vm_name}:${remote_path} ${local_file}"
}

# Check if VM exists and is running
# Usage: lima_is_running <vm_name>
lima_is_running() {
  local vm_name="$1"

  limactl list 2>/dev/null | grep "^${vm_name} " | grep -q "Running"
}

# Get all Warren VMs
# Usage: lima_list_warren_vms
lima_list_warren_vms() {
  limactl list 2>/dev/null | grep "^${VM_NAME_PREFIX}-" | awk '{print $1}' || true
}

# Get VM status
# Usage: lima_get_status <vm_name>
lima_get_status() {
  local vm_name="$1"

  limactl list 2>/dev/null | grep "^${vm_name} " | awk '{print $2}' || echo "NotFound"
}

# Create all cluster VMs
# Usage: lima_create_cluster_vms <num_managers> <num_workers> <cpus> <memory_gb>
lima_create_cluster_vms() {
  local num_managers="$1"
  local num_workers="$2"
  local cpus="$3"
  local memory="$4"

  log_step "Creating Lima VMs"

  # Create manager VMs
  log_info "Creating ${num_managers} manager VMs..."
  for ((i=1; i<=num_managers; i++)); do
    local vm_name="${VM_NAME_PREFIX}-manager-${i}"
    lima_create_vm "$vm_name" "$cpus" "$memory" || return 1
    lima_wait_ready "$vm_name" || return 1
  done

  # Create worker VMs
  log_info "Creating ${num_workers} worker VMs..."
  for ((i=1; i<=num_workers; i++)); do
    local vm_name="${VM_NAME_PREFIX}-worker-${i}"
    lima_create_vm "$vm_name" "$cpus" "$memory" || return 1
    lima_wait_ready "$vm_name" || return 1
  done

  log_success "All VMs created successfully"
  log_info "Manager VMs: ${num_managers}"
  log_info "Worker VMs: ${num_workers}"
  log_info "Total VMs: $((num_managers + num_workers))"

  return 0
}

# ============================================================================
# EXPORT FUNCTIONS
# ============================================================================

# Make functions available to sourcing scripts
export -f lima_create_vm
export -f lima_generate_config
export -f lima_delete_vm
export -f lima_start_vm
export -f lima_stop_vm
export -f lima_exec
export -f lima_exec_root
export -f lima_get_ip
export -f lima_wait_ready
export -f lima_copy_to_vm
export -f lima_copy_from_vm
export -f lima_is_running
export -f lima_list_warren_vms
export -f lima_get_status
export -f lima_create_cluster_vms

log_verbose "Lima utilities library loaded"
